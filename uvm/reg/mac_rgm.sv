//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant UVM V4.9 (Build 2)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : lenovo
// Unit            : vreguvm_pkg_uvm
// File            : vreguvm_pkg_uvm.sv
//----------------------------------------------------------------------
// Created by      : lenovo
// Creation Date   : 24-7-29 ÉÏÎç11:54
//----------------------------------------------------------------------
// Title           : lenovo
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// vreguvm_pkg_uvm
//----------------------------------------------------------------------
//package vreguvm_pkg_uvm;
`ifndef MAC_RGM_SV
`define MAC_RGM_SV
   import uvm_pkg::*;

   `include "uvm_macros.svh"

   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: tx_packet_count_reg
   // 
   //--------------------------------------------------------------------

   class tx_packet_count_reg extends uvm_reg;
      `uvm_object_utils(tx_packet_count_reg)

      uvm_reg_field tx_packets_count; // counter for all tx packets


      // Function: new
      // 
      function new(string name = "tx_packet_count_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_packets_count = uvm_reg_field::type_id::create("tx_packets_count");

         tx_packets_count.configure(this, 32, 0, "RO", 0, 32'h00000000, 1, 0, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: interrupt_state_reg
   // 
   // Each bit corresponds to an interrupt in the interrupt pending register
   //--------------------------------------------------------------------

   class interrupt_state_reg extends uvm_reg;
      `uvm_object_utils(interrupt_state_reg)

      uvm_reg_field reserved; 
      uvm_reg_field rx_fragment_err; 
      uvm_reg_field rx_crc_err; 
      uvm_reg_field rx_pause_frame; 
      uvm_reg_field remote_fault; 
      uvm_reg_field loacl_fault; 
      uvm_reg_field rx_fifo_udf; 
      uvm_reg_field rx_fifo_ovf; 
      uvm_reg_field tx_fifo_udf; 
      uvm_reg_field tx_fifo_ovf; 


      // Function: new
      // 
      function new(string name = "interrupt_state_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         rx_fragment_err = uvm_reg_field::type_id::create("rx_fragment_err");
         rx_crc_err = uvm_reg_field::type_id::create("rx_crc_err");
         rx_pause_frame = uvm_reg_field::type_id::create("rx_pause_frame");
         remote_fault = uvm_reg_field::type_id::create("remote_fault");
         loacl_fault = uvm_reg_field::type_id::create("loacl_fault");
         rx_fifo_udf = uvm_reg_field::type_id::create("rx_fifo_udf");
         rx_fifo_ovf = uvm_reg_field::type_id::create("rx_fifo_ovf");
         tx_fifo_udf = uvm_reg_field::type_id::create("tx_fifo_udf");
         tx_fifo_ovf = uvm_reg_field::type_id::create("tx_fifo_ovf");

         reserved.configure(this, 23, 9, "RO", 0, 23'b00000000000000000000000, 1, 0, 0);
         rx_fragment_err.configure(this, 1, 8, "RO", 0, 1'b0, 1, 0, 0);
         rx_crc_err.configure(this, 1, 7, "RO", 0, 1'b0, 1, 0, 0);
         rx_pause_frame.configure(this, 1, 6, "RO", 0, 1'b0, 1, 0, 0);
         remote_fault.configure(this, 1, 5, "RO", 0, 1'b0, 1, 0, 0);
         loacl_fault.configure(this, 1, 4, "RO", 0, 1'b0, 1, 0, 0);
         rx_fifo_udf.configure(this, 1, 3, "RO", 0, 1'b0, 1, 0, 0);
         rx_fifo_ovf.configure(this, 1, 2, "RO", 0, 1'b0, 1, 0, 0);
         tx_fifo_udf.configure(this, 1, 1, "RO", 0, 1'b0, 1, 0, 0);
         tx_fifo_ovf.configure(this, 1, 0, "RO", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: rx_octets_count_reg
   // 
   //--------------------------------------------------------------------

   class rx_octets_count_reg extends uvm_reg;
      `uvm_object_utils(rx_octets_count_reg)

      uvm_reg_field rx_octets_count; // counter for all rx octets


      // Function: new
      // 
      function new(string name = "rx_octets_count_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         rx_octets_count = uvm_reg_field::type_id::create("rx_octets_count");

         rx_octets_count.configure(this, 32, 0, "RO", 0, 32'h00000000, 1, 0, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: configuration_reg
   // 
   // TX ENABLE control
   //--------------------------------------------------------------------

   class configuration_reg extends uvm_reg;
      `uvm_object_utils(configuration_reg)

      uvm_reg_field reserved; // Reserved field,Reading returns zeros
      rand uvm_reg_field tx_enable; // when set,transmission of frames is enabled.This bit is set by default


      // Function: new
      // 
      function new(string name = "configuration_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         tx_enable = uvm_reg_field::type_id::create("tx_enable");

         reserved.configure(this, 31, 1, "RO", 0, 31'b0000000000000000000000000000000, 1, 0, 0);
         tx_enable.configure(this, 1, 0, "RW", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: tx_octets_count_reg
   // 
   //--------------------------------------------------------------------

   class tx_octets_count_reg extends uvm_reg;
      `uvm_object_utils(tx_octets_count_reg)

      uvm_reg_field tx_octets_count; // counter for all tx octets


      // Function: new
      // 
      function new(string name = "tx_octets_count_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_octets_count = uvm_reg_field::type_id::create("tx_octets_count");

         tx_octets_count.configure(this, 32, 0, "RO", 0, 32'h00000000, 1, 0, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: interrupt_pending_reg
   // 
   // This register is clear-on-read and provides an indication of pending interrupts
   //--------------------------------------------------------------------

   class interrupt_pending_reg extends uvm_reg;
      `uvm_object_utils(interrupt_pending_reg)

      uvm_reg_field reserved; // Reserved field,Reading returns zeros
      uvm_reg_field rx_fragment_err; // when set,indicates that a fragment was received
      uvm_reg_field rx_crc_err; // when set,indicates that a frame was received with invaild crc
      uvm_reg_field rx_pause_frame; // when set,indicates that a pause frame was received
      uvm_reg_field remote_fault; // when set,indicates that fault state-machine has transitioned in or out of remote fault condition
      uvm_reg_field loacl_fault; // when set,indicates that fault state-machine has transitioned in or out of local fault condition
      uvm_reg_field rx_fifo_udf; // when set,indicates that transmit data fifo has underflow
      uvm_reg_field rx_fifo_ovf; // when set,receive data fifo has overflow
      uvm_reg_field tx_fifo_udf; // when set,indicates that transmit data fifo has underflow,this situation should never occur
      uvm_reg_field tx_fifo_ovf; // when set,transmit data fifo has overflow


      // Function: new
      // 
      function new(string name = "interrupt_pending_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         rx_fragment_err = uvm_reg_field::type_id::create("rx_fragment_err");
         rx_crc_err = uvm_reg_field::type_id::create("rx_crc_err");
         rx_pause_frame = uvm_reg_field::type_id::create("rx_pause_frame");
         remote_fault = uvm_reg_field::type_id::create("remote_fault");
         loacl_fault = uvm_reg_field::type_id::create("loacl_fault");
         rx_fifo_udf = uvm_reg_field::type_id::create("rx_fifo_udf");
         rx_fifo_ovf = uvm_reg_field::type_id::create("rx_fifo_ovf");
         tx_fifo_udf = uvm_reg_field::type_id::create("tx_fifo_udf");
         tx_fifo_ovf = uvm_reg_field::type_id::create("tx_fifo_ovf");

         reserved.configure(this, 23, 9, "RO", 0, 23'b00000000000000000000000, 1, 0, 0);
         rx_fragment_err.configure(this, 1, 8, "RC", 0, 1'b0, 1, 0, 0);
         rx_crc_err.configure(this, 1, 7, "RC", 0, 1'b0, 1, 0, 0);
         rx_pause_frame.configure(this, 1, 6, "RC", 0, 1'b0, 1, 0, 0);
         remote_fault.configure(this, 1, 5, "RC", 0, 1'b0, 1, 0, 0);
         loacl_fault.configure(this, 1, 4, "RC", 0, 1'b0, 1, 0, 0);
         rx_fifo_udf.configure(this, 1, 3, "RC", 0, 1'b0, 1, 0, 0);
         rx_fifo_ovf.configure(this, 1, 2, "RC", 0, 1'b0, 1, 0, 0);
         tx_fifo_udf.configure(this, 1, 1, "RC", 0, 1'b0, 1, 0, 0);
         tx_fifo_ovf.configure(this, 1, 0, "RC", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: rx_packet_count_reg
   // 
   //--------------------------------------------------------------------

   class rx_packet_count_reg extends uvm_reg;
      `uvm_object_utils(rx_packet_count_reg)

      uvm_reg_field rx_packets_count; // counter for all rx packets


      // Function: new
      // 
      function new(string name = "rx_packet_count_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         rx_packets_count = uvm_reg_field::type_id::create("rx_packets_count");

         rx_packets_count.configure(this, 32, 0, "RO", 0, 32'h00000000, 1, 0, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: interrupt_mask_reg
   // 
   // Each bit corresponds to an interrupt in the interrupt pending register.Setting a bit enables the interrupt
   //--------------------------------------------------------------------

   class interrupt_mask_reg extends uvm_reg;
      `uvm_object_utils(interrupt_mask_reg)

      uvm_reg_field reserved; 
      uvm_reg_field rx_fragment_err; 
      uvm_reg_field rx_crc_err; 
      uvm_reg_field rx_pause_frame; 
      uvm_reg_field remote_fault; 
      uvm_reg_field loacl_fault; 
      uvm_reg_field rx_fifo_udf; 
      uvm_reg_field rx_fifo_ovf; 
      uvm_reg_field tx_fifo_udf; 
      uvm_reg_field tx_fifo_ovf; 


      // Function: new
      // 
      function new(string name = "interrupt_mask_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         rx_fragment_err = uvm_reg_field::type_id::create("rx_fragment_err");
         rx_crc_err = uvm_reg_field::type_id::create("rx_crc_err");
         rx_pause_frame = uvm_reg_field::type_id::create("rx_pause_frame");
         remote_fault = uvm_reg_field::type_id::create("remote_fault");
         loacl_fault = uvm_reg_field::type_id::create("loacl_fault");
         rx_fifo_udf = uvm_reg_field::type_id::create("rx_fifo_udf");
         rx_fifo_ovf = uvm_reg_field::type_id::create("rx_fifo_ovf");
         tx_fifo_udf = uvm_reg_field::type_id::create("tx_fifo_udf");
         tx_fifo_ovf = uvm_reg_field::type_id::create("tx_fifo_ovf");

         reserved.configure(this, 23, 9, "RW", 0, 23'b00000000000000000000000, 1, 0, 0);
         rx_fragment_err.configure(this, 1, 8, "RW", 0, 1'b0, 1, 0, 0);
         rx_crc_err.configure(this, 1, 7, "RW", 0, 1'b0, 1, 0, 0);
         rx_pause_frame.configure(this, 1, 6, "RW", 0, 1'b0, 1, 0, 0);
         remote_fault.configure(this, 1, 5, "RW", 0, 1'b0, 1, 0, 0);
         loacl_fault.configure(this, 1, 4, "RW", 0, 1'b0, 1, 0, 0);
         rx_fifo_udf.configure(this, 1, 3, "RW", 0, 1'b0, 1, 0, 0);
         rx_fifo_ovf.configure(this, 1, 2, "RW", 0, 1'b0, 1, 0, 0);
         tx_fifo_udf.configure(this, 1, 1, "RW", 0, 1'b0, 1, 0, 0);
         tx_fifo_ovf.configure(this, 1, 0, "RW", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: mac_rgm
   // 
   // Register block
   //--------------------------------------------------------------------

   class mac_rgm extends uvm_reg_block;
      `uvm_object_utils(mac_rgm)

      rand configuration_reg configuration; // TX ENABLE control
      rand interrupt_pending_reg interrupt_pending; // This register is clear-on-read and provides an indication of pending interrupts
      rand interrupt_state_reg interrupt_state; // Each bit corresponds to an interrupt in the interrupt pending register
      rand interrupt_mask_reg interrupt_mask; // Each bit corresponds to an interrupt in the interrupt pending register.Setting a bit enables the interrupt
      rand tx_octets_count_reg tx_octets_count; 
      rand tx_packet_count_reg tx_packet_count; 
      rand rx_octets_count_reg rx_octets_count; 
      rand rx_packet_count_reg rx_packet_count; 

      uvm_reg_map default_map; 


      // Function: new
      // 
      function new(string name = "mac_rgm");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         configuration = configuration_reg::type_id::create("configuration");
         configuration.configure(this);
         configuration.build();

         interrupt_pending = interrupt_pending_reg::type_id::create("interrupt_pending");
         interrupt_pending.configure(this);
         interrupt_pending.build();

         interrupt_state = interrupt_state_reg::type_id::create("interrupt_state");
         interrupt_state.configure(this);
         interrupt_state.build();

         interrupt_mask = interrupt_mask_reg::type_id::create("interrupt_mask");
         interrupt_mask.configure(this);
         interrupt_mask.build();

         tx_octets_count = tx_octets_count_reg::type_id::create("tx_octets_count");
         tx_octets_count.configure(this);
         tx_octets_count.build();

         tx_packet_count = tx_packet_count_reg::type_id::create("tx_packet_count");
         tx_packet_count.configure(this);
         tx_packet_count.build();

         rx_octets_count = rx_octets_count_reg::type_id::create("rx_octets_count");
         rx_octets_count.configure(this);
         rx_octets_count.build();

         rx_packet_count = rx_packet_count_reg::type_id::create("rx_packet_count");
         rx_packet_count.configure(this);// backdoor path
         rx_packet_count.build();

         default_map = create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = default_map;

         default_map.add_reg(configuration, 'h0, "RW");
         default_map.add_reg(interrupt_pending, 'h8, "RW");
         default_map.add_reg(interrupt_state, 'hc, "RW");
         default_map.add_reg(interrupt_mask, 'h10, "RW");
         default_map.add_reg(tx_octets_count, 'h80, "RW");
         default_map.add_reg(tx_packet_count, 'h84, "RW");
         default_map.add_reg(rx_octets_count, 'h90, "RW");
         default_map.add_reg(rx_packet_count, 'h94, "RW");

         lock_model();
      endfunction
   endclass

 `endif
//endpackage
